A modules is an encapsulated and reusable chunk of code that has its own context

in node js each file treated as a sperate module
## Types of module
1. local modules modules that we create in our application
2. built in modules Modules that Node.js ships with out of the box
3. Third party modules: modules written by other developer that is used by us

### Very basic Example

add.js
```javascript
const add = (a, b) => {
  return a + b;
};
const sum = add(1, 2);
console.log(sum);
```

index.js
```
console.log("hello world")
```
if you will try doing `node index.js`  it will print `hello world`
because in node each folder is sperate module

to get add.js add to index.js you have to do something like this

```javascript
require("./add.js");
console.log("hello world");
```
> output
> 2
> hello world


## Right way to work with modules
you  should expose function from add folder instead of writing everything there
add.js
```javascript
const add = (a, b) => {
  return a + b;
};
module.exports = add;
```

you have exposed your function by doing this 

now you can use it in any file by require
index.js
```javascript
const add = require("./add.js");
// also you can call it like `const addFn = require("./add.js");`

console.log(add(1, 7));

console.log("hello world");
```



# Module Scope
superman.js
```javascript
const superHero="Superman";
console.log(superHero);
```

batman.js
```javascript
const superHero="Batman";
console.log(superHero);
```

index .js
```javascript
require("./superman.js");
require("./batman.js");
```
>Output
>Superman
>Batman

both will happen why this is happening because both of these module will have different scope

> how JavaScript achieves this?
> ans :- achieved by js using Immediately invoked function call function `IFIF`.
> (function(){
const superhero="Superman";
console.log([[superHero]]);
})()
> 
> (function(){
> const superHero="Batman";
console.log(superHero);
})()


# Module Wrapper
we know evry module wrapped in IIFE
==this contains 5 parameters==

first lets see IIFE in js

```js
(function(message){
 const superHero="Batman";
console.log(superHero,message);
})("Hello")
```
>This is how we give values to IFFE

This is how we give values to IFFE

## Example
index.js
```js
const superHero="Batman"
console.log(superHero)
```
it will be converted to with ==all 5 parameter as following==
```js
(
	function(export, require, module, __filename, __dirnam){
		const superHero="Batman"
		console.log(superHero)
	}
)
```

behind the scene node is creating every module to IIFE and add these values to and they are available to use in every module wrapper

# Module Caching

In Node.js, when a module is required, it is cached, meaning that subsequent calls to `require` for the same module will reuse the initial export.

To utilize module caching effectively, it is recommended to export a class or function directly rather than exporting an instance of the class.

Correct usage:
```javascript
// Exporting a class or function
module.exports = SuperHero;
```
Avoid exporting an instance directly
```js
// Incorrect: Exporting an instance
module.exports = new SuperHero();
```
Exporting the class or function allows for flexibility and reusability, enabling consumers to create instances as needed.

# Import-Export Patterns in Node.js

1. **Import and Export Single Value:**
   - Exporting:
     ```javascript
     module.exports = add;
     ```
   - Importing:
     ```javascript
     const add = require("./math.js");
     ```

2. **Import Directly:**
   - Exporting:
     ```javascript
     module.exports = (a, b) => a + b;
     ```
   - Importing:
     ```javascript
     const add = require("./math.js");
     ```

3. **Import and Export Multiple:**
   - Exporting:
     ```javascript
     const add = (a, b) => a + b;
     const sub = (a, b) => a - b;
     module.exports = { add, sub };
     ```
   - Importing:
     ```javascript
     const math = require("./math");
     const { add, sub } = math;
     // or
     math.add(1, 2) and math.sub(1, 2);
     ```

4. **Import and Export Multiple Directly:**
   - Exporting:
     ```javascript
     module.exports.add = (a, b) => a + b;
     module.exports.sub = (a, b) => a - b;
     ```
   - Importing:
     ```javascript
     const math = require("./math");
     const { add, sub } = math;
     // or
     math.add(1, 2) and math.sub(1, 2);
     ```

5. **Just Export Way (Discouraged):**
   - Exporting:
     ```javascript
     exports.add = (a, b) => a + b;
     exports.sub = (a, b) => a - b;
     ```
   - Importing:
     ```javascript
     const math = require("./math");
     const { add, sub } = math;
     // or
     math.add(1, 2) and math.sub(1, 2);
     ```

   **Note:** It is discouraged to use `exports` directly as it is not a deep copy from the module, which may lead to scenarios where incorrect values may get added. Prefer using `module.exports` for consistency and reliability.
