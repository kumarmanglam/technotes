
A stream is a sequence of data that is being moved from one point to another. Streams ==help in transferring data in chunks==, improving efficiency by avoiding unnecessary data download and memory usage.

### Copy Data from File1 to File2:

```javascript
const fs = require("node:fs");

// Create a readable stream from file1
const readableStream = fs.createReadStream("./file1.txt", { encoding: "utf-8", highWaterMark: 2 });

// Create a writable stream to file2
const writableStream = fs.createWriteStream("file2.txt");

// Event handler for 'data' event
readableStream.on("data", (chunk) => {
  console.log(chunk);
  writableStream.write(chunk);
});
```

Output:
```plaintext
he
ll
o 
bu
dd
y
```

### Types of Streams in Node.js:

1. **Readable Stream:**
   
   ```javascript
   const fs = require('fs');

   const readableStream = fs.createReadStream('input.txt');

   readableStream.on('data', (chunk) => {
     console.log(`Received ${chunk.length} bytes of data.`);
   });

   readableStream.on('end', () => {
     console.log('No more data to read.');
   });

   readableStream.on('error', (err) => {
     console.error('Error:', err);
   });
   ```

In this example, we create a readable stream using `fs.createReadStream()` to read data from a file named 'input.txt'. We attach event listeners to handle the 'data' event, which is triggered when data becomes available to be read. We also handle the 'end' event to indicate the end of the stream, and the 'error' event to handle any errors that occur during reading.


2. **Writable Stream:**

   ```javascript
   const fs = require('fs');

   const writableStream = fs.createWriteStream('output.txt');

   writableStream.write('Hello, World!');
   writableStream.write('This is some data.');

   writableStream.end();

   writableStream.on('finish', () => {
     console.log('Data has been written to the file.');
   });

   writableStream.on('error', (err) => {
     console.error('Error:', err);
   });
   ```

In this example, we create a writable stream using `fs.createWriteStream()` to write data to a file named 'output.txt'. We use the `write()` method to write data to the stream and then call `end()` to signal the end of the stream. We can listen to the '==finish==' event to know when all the data has been written to the file, and the 'error' event to handle any errors that occur during writing.

3. **Duplex Stream:**

   ```javascript
   const net = require('net');

   const duplexStream = net.connect(8080, 'localhost');

   duplexStream.on('data', (data) => {
     console.log('Received data:', data.toString());
   });

   duplexStream.write('Hello, Server!');
   duplexStream.write('How are you?');

   duplexStream.on('end', () => {
     console.log('Stream connection closed.');
   });

   duplexStream.on('error', (err) => {
     console.error('Error:', err);
   });
   ```
In this example, we create a duplex stream by connecting to a server using the `net.connect()` method. The duplex stream ==allows us to both read data from the server and write data to it. ==We attach event listeners to handle the 'data' event to read data from the stream, the 'end' event to handle the end of the stream, and the 'error' event to handle any errors.

4. **Transform Stream:**

   ```javascript
   const fs = require('fs');
   const { Transform } = require('stream');

   const transformStream = new Transform({
     transform(chunk, encoding, callback) {
       const uppercasedChunk = chunk.toString().toUpperCase();
       this.push(uppercasedChunk);
       callback();
     }
   });

   const readableStream = fs.createReadStream('input.txt');
   const writableStream = fs.createWriteStream('output.txt');

   readableStream.pipe(transformStream).pipe(writableStream);
   ```

These examples cover basic operations with different types of streams in Node.js, including reading, writing, duplex, and transform streams. Streams provide an efficient way to handle large amounts of data in a non-blocking manner.